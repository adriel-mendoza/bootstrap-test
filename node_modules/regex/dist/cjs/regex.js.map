{
  "version": 3,
  "sources": ["../../src/regex.js", "../../src/utils-internals.js", "../../node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js", "../../src/atomic.js", "../../src/pattern.js", "../../src/utils.js", "../../src/backcompat.js", "../../src/flag-n.js", "../../src/flag-x.js", "../../src/subclass.js", "../../src/subroutines.js"],
  "sourcesContent": ["import {atomic, possessive} from './atomic.js';\nimport {backcompatPlugin} from './backcompat.js';\nimport {flagNPreprocessor} from './flag-n.js';\nimport {clean, flagXPreprocessor} from './flag-x.js';\nimport {Pattern, pattern} from './pattern.js';\nimport {RegExpSubclass} from './subclass.js';\nimport {subroutines} from './subroutines.js';\nimport {adjustNumberedBackrefs, CharClassContext, containsCharClassUnion, countCaptures, enclosedTokenCharClassContexts, enclosedTokenRegexContexts, envSupportsFlagGroups, envSupportsFlagV, escapeV, getBreakoutChar, getEndContextForIncompleteExpression, preprocess, RegexContext, sandboxLoneCharClassCaret, sandboxLoneDoublePunctuatorChar, sandboxUnsafeNulls} from './utils.js';\nimport {Context, hasUnescaped, replaceUnescaped} from 'regex-utilities';\n\n/**\n@typedef {string | RegExp | Pattern | number} InterpolatedValue\n@typedef {{\n  flags?: string;\n  captureTransfers?: Map<number, Array<number>>;\n  hiddenCaptures?: Array<number>;\n}} PluginData\n@typedef {{\n  pattern: string;\n  captureTransfers?: Map<number, Array<number>>;\n  hiddenCaptures?: Array<number>;\n}} PluginResult\n@typedef {TemplateStringsArray | {raw: Array<string>}} RawTemplate\n@typedef {{\n  flags?: string;\n  subclass?: boolean;\n  plugins?: Array<(expression: string, data: PluginData) => PluginResult>;\n  unicodeSetsPlugin?: ((expression: string, data: PluginData) => PluginResult) | null;\n  disable?: {\n    x?: boolean;\n    n?: boolean;\n    v?: boolean;\n    atomic?: boolean;\n    subroutines?: boolean;\n  };\n  force?: {\n    v?: boolean;\n  };\n}} RegexTagOptions\n*/\n/**\n@template T\n@typedef RegexTag\n@type {{\n  (template: RawTemplate, ...substitutions: ReadonlyArray<InterpolatedValue>): T;\n  (flags?: string): RegexTag<T>;\n  (options: RegexTagOptions & {subclass?: false}): RegexTag<T>;\n  (options: RegexTagOptions & {subclass: true}): RegexTag<RegExpSubclass>;\n}}\n*/\n/**\nTemplate tag for constructing a regex with extended syntax and context-aware interpolation of\nregexes, strings, and patterns.\n\nCan be called in several ways:\n1. `` regex`\u2026` `` - Regex pattern as a raw string.\n2. `` regex('gi')`\u2026` `` - To specify flags.\n3. `` regex({flags: 'gi'})`\u2026` `` - With options.\n@type {RegexTag<RegExp>}\n*/\nconst regex = (first, ...substitutions) => {\n  // Given a template\n  if (Array.isArray(first?.raw)) {\n    return regexFromTemplate({}, first, ...substitutions);\n  // Given flags\n  } else if ((typeof first === 'string' || first === undefined) && !substitutions.length) {\n    return regexFromTemplate.bind(null, {flags: first ?? ''});\n  // Given an options object\n  } else if ({}.toString.call(first) === '[object Object]' && !substitutions.length) {\n    return regexFromTemplate.bind(null, first);\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...substitutions])}`);\n};\n\n/**\n@template T\n@typedef RegexFromTemplate\n@type {{\n  (options: RegexTagOptions, template: RawTemplate, ...substitutions: ReadonlyArray<InterpolatedValue>) : T;\n}}\n*/\n/**\nReturns a RegExp from a template and substitutions to fill the template holes.\n@type {RegexFromTemplate<RegExp>}\n*/\nconst regexFromTemplate = (options, template, ...substitutions) => {\n  const opts = getOptions(options);\n  const prepped = runPreprocessors(template, substitutions, opts);\n\n  let precedingCaptures = 0;\n  let expression = '';\n  let runningContext;\n  // Intersperse raw template strings and substitutions\n  prepped.template.raw.forEach((raw, i) => {\n    const wrapEscapedStr = !!(prepped.template.raw[i] || prepped.template.raw[i + 1]);\n    // Even with flag n enabled, we might have named captures\n    precedingCaptures += countCaptures(raw);\n    // Sandbox `\\0` in character classes. Not needed outside character classes because in other\n    // cases a following interpolated value would always be atomized\n    expression += sandboxUnsafeNulls(raw, Context.CHAR_CLASS);\n    runningContext = getEndContextForIncompleteExpression(expression, runningContext);\n    const {regexContext, charClassContext} = runningContext;\n    if (i < prepped.template.raw.length - 1) {\n      const substitution = prepped.substitutions[i];\n      expression += interpolate(substitution, opts.flags, regexContext, charClassContext, wrapEscapedStr, precedingCaptures);\n      if (substitution instanceof RegExp) {\n        precedingCaptures += countCaptures(substitution.source);\n      } else if (substitution instanceof Pattern) {\n        precedingCaptures += countCaptures(String(substitution));\n      }\n    }\n  });\n\n  const plugged = runPlugins(expression, opts);\n  expression = plugged.pattern;\n  try {\n    return opts.subclass ?\n      new RegExpSubclass(expression, opts.flags, {hiddenCaptures: plugged.hiddenCaptures}) :\n      new RegExp(expression, opts.flags);\n  } catch (err) {\n    // Improve DX by always including the generated source in the error message. Some browsers\n    // include it automatically, but not Firefox or Safari\n    const stripped = err.message.replace(/ \\/.+\\/[a-z]*:/, '');\n    err.message = `${stripped}: /${expression}/${opts.flags}`;\n    throw err;\n  }\n};\n\n/**\nReturns the processed expression and flags as strings.\n@param {string} expression\n@param {RegexTagOptions} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n}}\n*/\nfunction rewrite(expression = '', options) {\n  const opts = getOptions(options);\n  if (opts.subclass) {\n    throw new Error('Cannot use option subclass');\n  }\n  return {\n    // NOTE: Since `pattern` is a Regex+ export with special meaning, the term `expression` is used\n    // in code to refer to regex source strings, except in the public API\n    pattern: runPlugins(\n      runPreprocessors({raw: [expression]}, [], opts).template.raw[0],\n      opts\n    ).pattern,\n    flags: opts.flags,\n  };\n}\n\n/**\nReturns a complete set of options, with default values set for options that weren't provided, and\nsome options augmented for use.\n@param {RegexTagOptions} [options]\n@returns {Required<RegexTagOptions>}\n*/\nfunction getOptions(options) {\n  const opts = {\n    flags: '',\n    subclass: false,\n    plugins: [],\n    unicodeSetsPlugin: backcompatPlugin,\n    disable: {/* n, v, x, atomic, subroutines */},\n    force: {/* v */},\n    ...options,\n  };\n  if (/[nuvx]/.test(opts.flags)) {\n    throw new Error('Implicit flags v/u/x/n cannot be explicitly added');\n  }\n  const useFlagV = opts.force.v || (opts.disable.v ? false : envSupportsFlagV);\n  opts.flags += useFlagV ? 'v' : 'u';\n  if (useFlagV) {\n    opts.unicodeSetsPlugin = null;\n  }\n  return opts;\n}\n\n/**\n@param {RawTemplate} template\n@param {ReadonlyArray<InterpolatedValue>} substitutions\n@param {Required<RegexTagOptions>} options\n@returns {{\n  template: RawTemplate;\n  substitutions: ReadonlyArray<InterpolatedValue>;\n}}\n*/\nfunction runPreprocessors(template, substitutions, options) {\n  const preprocessors = [];\n  // Implicit flag x is handled first because otherwise some regex syntax (if unescaped) within\n  // comments could cause problems when parsing\n  if (!options.disable.x) {\n    preprocessors.push(flagXPreprocessor);\n  }\n  // Implicit flag n is a preprocessor because capturing groups affect backreference rewriting in\n  // both interpolation and plugins\n  if (!options.disable.n) {\n    preprocessors.push(flagNPreprocessor);\n  }\n  for (const pp of preprocessors) {\n    ({template, substitutions} = preprocess(template, substitutions, pp, options));\n  }\n  return {\n    template,\n    substitutions,\n  };\n}\n\n/**\n@param {string} expression\n@param {Required<RegexTagOptions>} options\n@returns {Required<PluginResult>}\n*/\nfunction runPlugins(expression, {flags, plugins, unicodeSetsPlugin, disable}) {\n  let hiddenCaptures = [];\n  [ ...plugins, // Run first, so provided plugins can output extended syntax\n    ...(disable.subroutines ? [] : [subroutines]),\n    ...(disable.atomic      ? [] : [possessive, atomic]),\n    ...(disable.x           ? [] : [clean]),\n    // Run last, so it doesn't have to worry about parsing extended syntax\n    ...(!unicodeSetsPlugin  ? [] : [unicodeSetsPlugin]),\n  ].forEach(plugin => {\n    const result = plugin(expression, {flags, hiddenCaptures});\n    if (typeof result?.pattern !== 'string') {\n      throw new Error('Plugin must return an object with a string property \"pattern\"');\n    }\n    expression = result.pattern;\n    if (result.hiddenCaptures) {\n      hiddenCaptures = result.hiddenCaptures;\n    }\n  });\n  return {\n    pattern: expression,\n    hiddenCaptures,\n  };\n}\n\n/**\n@param {InterpolatedValue} value\n@param {string} flags\n@param {string} regexContext\n@param {string} charClassContext\n@param {boolean} wrapEscapedStr\n@param {number} precedingCaptures\n@returns {string}\n*/\nfunction interpolate(value, flags, regexContext, charClassContext, wrapEscapedStr, precedingCaptures) {\n  if (value instanceof RegExp && regexContext !== RegexContext.DEFAULT) {\n    throw new Error('Cannot interpolate a RegExp at this position because the syntax context does not match');\n  }\n  if (regexContext === RegexContext.INVALID_INCOMPLETE_TOKEN || charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN) {\n    // Throw in all cases, but only *need* to handle a preceding unescaped backslash (which would\n    // break sandboxing) since other errors would be handled by the invalid generated regex syntax\n    throw new Error('Interpolation preceded by invalid incomplete token');\n  }\n  if (\n    typeof value === 'number' &&\n    (regexContext === RegexContext.ENCLOSED_U || charClassContext === CharClassContext.ENCLOSED_U)\n  ) {\n    return value.toString(16);\n  }\n  const isPattern = value instanceof Pattern;\n  let escapedValue = '';\n  if (!(value instanceof RegExp)) {\n    value = String(value);\n    if (!isPattern) {\n      escapedValue = escapeV(\n        value,\n        regexContext === RegexContext.CHAR_CLASS ? Context.CHAR_CLASS : Context.DEFAULT\n      );\n    }\n    // Check `escapedValue` (not just patterns) since possible breakout char `>` isn't escaped\n    const breakoutChar = getBreakoutChar(escapedValue || value, regexContext, charClassContext);\n    if (breakoutChar) {\n      throw new Error(`Unescaped stray \"${breakoutChar}\" in the interpolated value would have side effects outside it`);\n    }\n  }\n\n  if (\n    regexContext === RegexContext.INTERVAL_QUANTIFIER ||\n    regexContext === RegexContext.GROUP_NAME ||\n    enclosedTokenRegexContexts.has(regexContext) ||\n    enclosedTokenCharClassContexts.has(charClassContext)\n  ) {\n    return isPattern ? String(value) : escapedValue;\n  } else if (regexContext === RegexContext.CHAR_CLASS) {\n    if (isPattern) {\n      if (hasUnescaped(String(value), '^-|^&&|-$|&&$')) {\n        // Sandboxing so we don't change the chars outside the pattern into being part of an\n        // operation they didn't initiate. Same problem as starting a pattern with a quantifier\n        throw new Error('Cannot use range or set operator at boundary of interpolated pattern; move the operation into the pattern or the operator outside of it');\n      }\n      const sandboxedValue = sandboxLoneCharClassCaret(sandboxLoneDoublePunctuatorChar(value));\n      // Atomize via nested character class `[\u2026]` if it contains implicit or explicit union (check\n      // the unadjusted value)\n      return containsCharClassUnion(value) ? `[${sandboxedValue}]` : sandboxUnsafeNulls(sandboxedValue);\n    }\n    // Atomize via nested character class `[\u2026]` if more than one node\n    return containsCharClassUnion(escapedValue) ? `[${escapedValue}]` : escapedValue;\n  }\n  // `RegexContext.DEFAULT`\n  if (value instanceof RegExp) {\n    const transformed = transformForLocalFlags(value, flags);\n    const backrefsAdjusted = adjustNumberedBackrefs(transformed.value, precedingCaptures);\n    // Sandbox and atomize; if we used a pattern modifier it has the same effect\n    return transformed.usedModifier ? backrefsAdjusted : `(?:${backrefsAdjusted})`;\n  }\n  if (isPattern) {\n    // Sandbox and atomize\n    return `(?:${value})`;\n  }\n  // Sandbox and atomize\n  return wrapEscapedStr ? `(?:${escapedValue})` : escapedValue;\n}\n\n/**\n@param {RegExp} re\n@param {string} outerFlags\n@returns {{value: string; usedModifier?: boolean;}}\n*/\nfunction transformForLocalFlags(re, outerFlags) {\n  /** @type {{i: boolean | null; m: boolean | null; s: boolean | null;}} */\n  const modFlagsObj = {\n    i: null,\n    m: null,\n    s: null,\n  };\n  const newlines = '\\\\n\\\\r\\\\u2028\\\\u2029';\n  let value = re.source;\n  if (re.ignoreCase !== outerFlags.includes('i')) {\n    if (envSupportsFlagGroups) {\n      modFlagsObj.i = re.ignoreCase;\n    } else {\n      throw new Error('Pattern modifiers not supported, so flag i on the outer and interpolated regex must match');\n    }\n  }\n  if (re.dotAll !== outerFlags.includes('s')) {\n    if (envSupportsFlagGroups) {\n      modFlagsObj.s = re.dotAll;\n    } else {\n      value = replaceUnescaped(value, '\\\\.', (re.dotAll ? '[^]' : `[^${newlines}]`), Context.DEFAULT);\n    }\n  }\n  if (re.multiline !== outerFlags.includes('m')) {\n    if (envSupportsFlagGroups) {\n      modFlagsObj.m = re.multiline;\n    } else {\n      value = replaceUnescaped(value, '\\\\^', (re.multiline ? `(?<=^|[${newlines}])` : '(?<![^])'), Context.DEFAULT);\n      value = replaceUnescaped(value, '\\\\$', (re.multiline ? `(?=$|[${newlines}])` : '(?![^])'), Context.DEFAULT);\n    }\n  }\n  if (envSupportsFlagGroups) {\n    const keys = Object.keys(modFlagsObj);\n    let modifier = keys.filter(k => modFlagsObj[k] === true).join('');\n    const modOff = keys.filter(k => modFlagsObj[k] === false).join('');\n    if (modOff) {\n      modifier += `-${modOff}`;\n    }\n    if (modifier) {\n      return {\n        value: `(?${modifier}:${value})`,\n        usedModifier: true,\n      };\n    }\n  }\n  return {value};\n}\n\nexport {\n  pattern,\n  regex,\n  rewrite,\n};\n", "// Separating some utils for improved tree shaking of the `./internals` export\n\nconst noncapturingDelim = String.raw`\\(\\?(?:[:=!>A-Za-z\\-]|<[=!]|\\(DEFINE\\))`;\n\n/**\nUpdates the array in place by incrementing each value greater than or equal to the threshold.\n@param {Array<number>} arr\n@param {number} threshold\n*/\nfunction incrementIfAtLeast(arr, threshold) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= threshold) {\n      arr[i]++;\n    }\n  }\n}\n\n/**\n@param {string} str\n@param {number} pos\n@param {string} oldValue\n@param {string} newValue\n@returns {string}\n*/\nfunction spliceStr(str, pos, oldValue, newValue) {\n  return str.slice(0, pos) + newValue + str.slice(pos + oldValue.length);\n}\n\nexport {\n  incrementIfAtLeast,\n  noncapturingDelim,\n  spliceStr,\n};\n", "// Constant properties for tracking regex syntax context\nexport const Context = Object.freeze({\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n});\n\n/**\nReplaces all unescaped instances of a regex pattern in the given context, using a replacement\nstring or callback.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {string | (match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => string} replacement\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {string} Updated expression\n@example\nconst str = '.\\\\.\\\\\\\\.[[\\\\.].].';\nreplaceUnescaped(str, '\\\\.', '@');\n// \u2192 '@\\\\.\\\\\\\\@[[\\\\.]@]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.DEFAULT);\n// \u2192 '@\\\\.\\\\\\\\@[[\\\\.].]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.CHAR_CLASS);\n// \u2192 '.\\\\.\\\\\\\\.[[\\\\.]@].'\n*/\nexport function replaceUnescaped(expression, needle, replacement, context) {\n  const re = new RegExp(String.raw`${needle}|(?<$skip>\\[\\^?|\\\\?.)`, 'gsu');\n  const negated = [false];\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const match of expression.matchAll(re)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      if (replacement instanceof Function) {\n        result += replacement(match, {\n          context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,\n          negated: negated[negated.length - 1],\n        });\n      } else {\n        result += replacement;\n      }\n      continue;\n    }\n    if (m[0] === '[') {\n      numCharClassesOpen++;\n      negated.push(m[1] === '^');\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n      negated.pop();\n    }\n    result += m;\n  }\n  return result;\n}\n\n/**\nRuns a callback for each unescaped instance of a regex pattern in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {(match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => void} callback\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n*/\nexport function forEachUnescaped(expression, needle, callback, context) {\n  // Do this the easy way\n  replaceUnescaped(expression, needle, callback, context);\n}\n\n/**\nReturns a match object for the first unescaped instance of a regex pattern in the given context, or\n`null`.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {number} [pos] Offset to start the search\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {RegExpExecArray | null}\n*/\nexport function execUnescaped(expression, needle, pos = 0, context) {\n  // Quick partial test; avoid the loop if not needed\n  if (!(new RegExp(needle, 'su').test(expression))) {\n    return null;\n  }\n  const re = new RegExp(`${needle}|(?<$skip>\\\\\\\\?.)`, 'gsu');\n  re.lastIndex = pos;\n  let numCharClassesOpen = 0;\n  let match;\n  while (match = re.exec(expression)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      return match;\n    }\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n    // Avoid an infinite loop on zero-length matches\n    if (re.lastIndex == match.index) {\n      re.lastIndex++;\n    }\n  }\n  return null;\n}\n\n/**\nChecks whether an unescaped instance of a regex pattern appears in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {boolean} Whether the pattern was found\n*/\nexport function hasUnescaped(expression, needle, context) {\n  // Do this the easy way\n  return !!execUnescaped(expression, needle, 0, context);\n}\n\n/**\nExtracts the full contents of a group (subpattern) from the given expression, accounting for\nescaped characters, nested groups, and character classes. The group is identified by the position\nwhere its contents start (the string index just after the group's opening delimiter). Returns the\nrest of the string if the group is unclosed.\n\nAssumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {number} contentsStartPos\n@returns {string}\n*/\nexport function getGroupContents(expression, contentsStartPos) {\n  const token = /\\\\?./gsu;\n  token.lastIndex = contentsStartPos;\n  let contentsEndPos = expression.length;\n  let numCharClassesOpen = 0;\n  // Starting search within an open group, after the group's opening\n  let numGroupsOpen = 1;\n  let match;\n  while (match = token.exec(expression)) {\n    const [m] = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (m === '(') {\n        numGroupsOpen++;\n      } else if (m === ')') {\n        numGroupsOpen--;\n        if (!numGroupsOpen) {\n          contentsEndPos = match.index;\n          break;\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return expression.slice(contentsStartPos, contentsEndPos);\n}\n", "import {incrementIfAtLeast, noncapturingDelim, spliceStr} from './utils-internals.js';\nimport {Context, replaceUnescaped} from 'regex-utilities';\n\nconst atomicPluginToken = new RegExp(String.raw`(?<noncapturingStart>${noncapturingDelim})|(?<capturingStart>\\((?:\\?<[^>]+>)?)|\\\\?.`, 'gsu');\n\n/**\nApply transformations for atomic groups: `(?>\u2026)`.\n@param {string} expression\n@param {import('./regex.js').PluginData} [data]\n@returns {Required<import('./regex.js').PluginResult>}\n*/\nfunction atomic(expression, data) {\n  const hiddenCaptures = data?.hiddenCaptures ?? [];\n  // Capture transfer is used by <github.com/slevithan/oniguruma-to-es>\n  let captureTransfers = data?.captureTransfers ?? new Map();\n  if (!/\\(\\?>/.test(expression)) {\n    return {\n      pattern: expression,\n      captureTransfers,\n      hiddenCaptures,\n    };\n  }\n\n  const aGDelim = '(?>';\n  const emulatedAGDelim = '(?:(?=(';\n  const captureNumMap = [0];\n  const addedHiddenCaptures = [];\n  let numCapturesBeforeAG = 0;\n  let numAGs = 0;\n  let aGPos = NaN;\n  let hasProcessedAG;\n  do {\n    hasProcessedAG = false;\n    let numCharClassesOpen = 0;\n    let numGroupsOpenInAG = 0;\n    let inAG = false;\n    let match;\n    atomicPluginToken.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + emulatedAGDelim.length;\n    while (match = atomicPluginToken.exec(expression)) {\n      const {0: m, index, groups: {capturingStart, noncapturingStart}} = match;\n      if (m === '[') {\n        numCharClassesOpen++;\n      } else if (!numCharClassesOpen) {\n\n        if (m === aGDelim && !inAG) {\n          aGPos = index;\n          inAG = true;\n        } else if (inAG && noncapturingStart) {\n          numGroupsOpenInAG++;\n        } else if (capturingStart) {\n          if (inAG) {\n            numGroupsOpenInAG++;\n          } else {\n            numCapturesBeforeAG++;\n            captureNumMap.push(numCapturesBeforeAG + numAGs);\n          }\n        } else if (m === ')' && inAG) {\n          if (!numGroupsOpenInAG) {\n            numAGs++;\n            const addedCaptureNum = numCapturesBeforeAG + numAGs;\n            // Replace `expression` and use `<$$N>` as a temporary wrapper for the backref so it\n            // can avoid backref renumbering afterward. Wrap the whole substitution (including the\n            // lookahead and following backref) in a noncapturing group to handle following\n            // quantifiers and literal digits\n            expression = `${expression.slice(0, aGPos)}${emulatedAGDelim}${\n                expression.slice(aGPos + aGDelim.length, index)\n              }))<$$${addedCaptureNum}>)${expression.slice(index + 1)}`;\n            hasProcessedAG = true;\n            addedHiddenCaptures.push(addedCaptureNum);\n            incrementIfAtLeast(hiddenCaptures, addedCaptureNum);\n            if (captureTransfers.size) {\n              const newCaptureTransfers = new Map();\n              captureTransfers.forEach((from, to) => {\n                newCaptureTransfers.set(\n                  to >= addedCaptureNum ? to + 1 : to,\n                  from.map(f => f >= addedCaptureNum ? f + 1 : f)\n                );\n              });\n              captureTransfers = newCaptureTransfers;\n            }\n            break;\n          }\n          numGroupsOpenInAG--;\n        }\n\n      } else if (m === ']') {\n        numCharClassesOpen--;\n      }\n    }\n  // Start over from the beginning of the atomic group's contents, in case the processed group\n  // contains additional atomic groups\n  } while (hasProcessedAG);\n\n  hiddenCaptures.push(...addedHiddenCaptures);\n\n  // Second pass to adjust numbered backrefs\n  expression = replaceUnescaped(\n    expression,\n    String.raw`\\\\(?<backrefNum>[1-9]\\d*)|<\\$\\$(?<wrappedBackrefNum>\\d+)>`,\n    ({0: m, groups: {backrefNum, wrappedBackrefNum}}) => {\n      if (backrefNum) {\n        const bNum = +backrefNum;\n        if (bNum > captureNumMap.length - 1) {\n          throw new Error(`Backref \"${m}\" greater than number of captures`);\n        }\n        return `\\\\${captureNumMap[bNum]}`;\n      }\n      return `\\\\${wrappedBackrefNum}`;\n    },\n    Context.DEFAULT\n  );\n\n  return {\n    pattern: expression,\n    captureTransfers,\n    hiddenCaptures,\n  };\n}\n\nconst baseQuantifier = String.raw`(?:[?*+]|\\{\\d+(?:,\\d*)?\\})`;\n// Complete tokenizer for base syntax; doesn't (need to) know about character-class-only syntax\nconst possessivePluginToken = new RegExp(String.raw`\n\\\\(?: \\d+\n  | c[A-Za-z]\n  | [gk]<[^>]+>\n  | [pPu]\\{[^\\}]+\\}\n  | u[A-Fa-f\\d]{4}\n  | x[A-Fa-f\\d]{2}\n  )\n| \\((?: \\? (?: [:=!>]\n  | <(?:[=!]|[^>]+>)\n  | [A-Za-z\\-]+:\n  | \\(DEFINE\\)\n  ))?\n| (?<qBase>${baseQuantifier})(?<qMod>[?+]?)(?<invalidQ>[?*+\\{]?)\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\nTransform posessive quantifiers into atomic groups. The posessessive quantifiers are:\n`?+`, `*+`, `++`, `{N}+`, `{N,}+`, `{N,N}+`.\nThis follows Java, PCRE, Perl, and Python.\nPossessive quantifiers in Oniguruma and Onigmo are only: `?+`, `*+`, `++`.\n@param {string} expression\n@returns {import('./regex.js').PluginResult}\n*/\nfunction possessive(expression) {\n  if (!(new RegExp(`${baseQuantifier}\\\\+`).test(expression))) {\n    return {\n      pattern: expression,\n    };\n  }\n\n  const openGroupIndices = [];\n  let lastGroupIndex = null;\n  let lastCharClassIndex = null;\n  let lastToken = '';\n  let numCharClassesOpen = 0;\n  let match;\n  possessivePluginToken.lastIndex = 0;\n  while (match = possessivePluginToken.exec(expression)) {\n    const {0: m, index, groups: {qBase, qMod, invalidQ}} = match;\n    if (m === '[') {\n      if (!numCharClassesOpen) {\n        lastCharClassIndex = index;\n      }\n      numCharClassesOpen++;\n    } else if (m === ']') {\n      if (numCharClassesOpen) {\n        numCharClassesOpen--;\n      // Unmatched `]`\n      } else {\n        lastCharClassIndex = null;\n      }\n    } else if (!numCharClassesOpen) {\n\n      if (qMod === '+' && lastToken && !lastToken.startsWith('(')) {\n        // Invalid following quantifier would become valid via the wrapping group\n        if (invalidQ) {\n          throw new Error(`Invalid quantifier \"${m}\"`);\n        }\n        let charsAdded = -1; // -1 for removed trailing `+`\n        // Possessivizing fixed repetition quantifiers like `{2}` does't change their behavior, so\n        // avoid doing so (convert them to greedy)\n        if (/^\\{\\d+\\}$/.test(qBase)) {\n          expression = spliceStr(expression, index + qBase.length, qMod, '');\n        } else {\n          if (lastToken === ')' || lastToken === ']') {\n            const nodeIndex = lastToken === ')' ? lastGroupIndex : lastCharClassIndex;\n            // Unmatched `)` would break out of the wrapping group and mess with handling.\n            // Unmatched `]` wouldn't be a problem, but it's unnecessary to have dedicated support\n            // for unescaped `]++` since this won't work with flag u or v anyway\n            if (nodeIndex === null) {\n              throw new Error(`Invalid unmatched \"${lastToken}\"`);\n            }\n            expression = `${expression.slice(0, nodeIndex)}(?>${expression.slice(nodeIndex, index)}${qBase})${expression.slice(index + m.length)}`;\n          } else {\n            expression = `${expression.slice(0, index - lastToken.length)}(?>${lastToken}${qBase})${expression.slice(index + m.length)}`;\n          }\n          charsAdded += 4; // `(?>)`\n        }\n        possessivePluginToken.lastIndex += charsAdded;\n      } else if (m[0] === '(') {\n        openGroupIndices.push(index);\n      } else if (m === ')') {\n        lastGroupIndex = openGroupIndices.length ? openGroupIndices.pop() : null;\n      }\n\n    }\n    lastToken = m;\n  }\n\n  return {\n    pattern: expression,\n  };\n}\n\nexport {\n  atomic,\n  possessive,\n};\n", "class Pattern {\n  #value;\n  /** @param {string} value */\n  constructor(value) {\n    this.#value = value;\n  }\n  /** @returns {string} */\n  toString() {\n    return String(this.#value);\n  }\n}\n\n/**\nReturns a value that can be interpolated into a `regex` template string without having its special\ncharacters escaped.\n\nCan be called as a function or template tag:\n- `pattern(value)` - String or value coerced to string.\n- `` pattern`\u2026` `` - Same as ``pattern(String.raw`\u2026`)``.\n\n@overload\n@param {string | number} value\n@returns {Pattern}\n\n@overload\n@param {TemplateStringsArray} template\n@param {...string} substitutions\n@returns {Pattern}\n*/\nfunction pattern(first, ...substitutions) {\n  if (Array.isArray(first?.raw)) {\n    return new Pattern(\n      // Intersperse raw template strings and substitutions\n      first.raw.flatMap((raw, i) => i < first.raw.length - 1 ? [raw, substitutions[i]] : raw).join('')\n    );\n  } else if (!substitutions.length) {\n    return new Pattern(first === undefined ? '' : first);\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...substitutions])}`);\n}\n\nexport {\n  Pattern,\n  pattern,\n};\n", "import {Pattern, pattern} from './pattern.js';\nimport {Context, forEachUnescaped, replaceUnescaped} from 'regex-utilities';\n\nconst RegexContext = {\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n  ENCLOSED_P: 'ENCLOSED_P',\n  ENCLOSED_U: 'ENCLOSED_U',\n  GROUP_NAME: 'GROUP_NAME',\n  INTERVAL_QUANTIFIER: 'INTERVAL_QUANTIFIER',\n  INVALID_INCOMPLETE_TOKEN: 'INVALID_INCOMPLETE_TOKEN',\n};\n\nconst CharClassContext = {\n  DEFAULT: 'DEFAULT',\n  ENCLOSED_P: 'ENCLOSED_P',\n  ENCLOSED_Q: 'ENCLOSED_Q',\n  ENCLOSED_U: 'ENCLOSED_U',\n  INVALID_INCOMPLETE_TOKEN: 'INVALID_INCOMPLETE_TOKEN',\n  RANGE: 'RANGE',\n};\n\nconst enclosedTokenRegexContexts = new Set([\n  RegexContext.ENCLOSED_P,\n  RegexContext.ENCLOSED_U,\n]);\n\nconst enclosedTokenCharClassContexts = new Set([\n  CharClassContext.ENCLOSED_P,\n  CharClassContext.ENCLOSED_Q,\n  CharClassContext.ENCLOSED_U,\n]);\n\nconst envSupportsFlagGroups = (() => {\n  try {\n    new RegExp('(?i:)');\n  } catch {\n    return false;\n  }\n  return true;\n})();\n\nconst envSupportsFlagV = (() => {\n  try {\n    new RegExp('', 'v');\n  } catch {\n    return false;\n  }\n  return true;\n})();\n\nconst doublePunctuatorChars = '&!#$%*+,.:;<=>?@^`~';\nconst namedCapturingDelim = String.raw`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nconst capturingDelim = String.raw`\\((?!\\?)(?!(?<=\\(\\?\\()DEFINE\\))|${namedCapturingDelim}`;\n\n/**\n@param {string} expression\n@param {number} precedingCaptures\n@returns {string}\n*/\nfunction adjustNumberedBackrefs(expression, precedingCaptures) {\n  return replaceUnescaped(\n    expression,\n    String.raw`\\\\(?<num>[1-9]\\d*)`,\n    ({groups: {num}}) => `\\\\${+num + precedingCaptures}`,\n    Context.DEFAULT\n  );\n}\n\n// Properties of strings as of ES2024\nconst stringPropertyNames = [\n  'Basic_Emoji',\n  'Emoji_Keycap_Sequence',\n  'RGI_Emoji_Modifier_Sequence',\n  'RGI_Emoji_Flag_Sequence',\n  'RGI_Emoji_Tag_Sequence',\n  'RGI_Emoji_ZWJ_Sequence',\n  'RGI_Emoji',\n].join('|');\nconst charClassUnionToken = new RegExp(String.raw`\n\\\\(?: c[A-Za-z]\n  | p\\{(?<pStrProp>${stringPropertyNames})\\}\n  | [pP]\\{[^\\}]+\\}\n  | (?<qStrProp>q)\n  | u(?:[A-Fa-f\\d]{4}|\\{[A-Fa-f\\d]+\\})\n  | x[A-Fa-f\\d]{2}\n  | .\n)\n| --\n| &&\n| .\n`.replace(/\\s+/g, ''), 'gsu');\n\n// Assumes flag v and doesn't worry about syntax errors that are caught by it\nfunction containsCharClassUnion(charClassPattern) {\n  // Return `true` if it contains:\n  // - `\\p` (lowercase only) and the name is a property of strings (case sensitive).\n  // - `\\q`.\n  // - Two single-char-matching tokens in sequence.\n  // - One single-char-matching token followed immediately by unescaped `[`.\n  // - One single-char-matching token preceded immediately by unescaped `]`.\n  // Else, `false`.\n  // Ranges with `-` create a single token.\n  // Subtraction and intersection with `--` and `&&` create a single token.\n  // Supports any number of nested classes\n  let hasFirst = false;\n  let lastM;\n  for (const {0: m, groups} of charClassPattern.matchAll(charClassUnionToken)) {\n    if (groups.pStrProp || groups.qStrProp) {\n      return true;\n    }\n    if (m === '[' && hasFirst) {\n      return true;\n    }\n    if (['-', '--', '&&'].includes(m)) {\n      hasFirst = false;\n    } else if (m !== '[' && m !== ']') {\n      if (hasFirst || lastM === ']') {\n        return true;\n      }\n      hasFirst = true;\n    }\n    lastM = m;\n  }\n  return false;\n}\n\n/**\n@param {string} expression\n@returns {number}\n*/\nfunction countCaptures(expression) {\n  let num = 0;\n  forEachUnescaped(expression, capturingDelim, () => num++, Context.DEFAULT);\n  return num;\n}\n\n/**\nEscape special characters for the given context, assuming flag v.\n@param {string} str String to escape\n@param {'DEFAULT' | 'CHAR_CLASS'} context `Context` option from lib `regex-utilities`\n@returns {string} Escaped string\n*/\nfunction escapeV(str, context) {\n  if (context === Context.CHAR_CLASS) {\n    // Escape all double punctuators (including ^, which is special on its own in the first\n    // position) in case they're bordered by the same character in or outside of the escaped string\n    return str.replace(new RegExp(String.raw`[()\\[\\]{}|\\\\/\\-${doublePunctuatorChars}]`, 'g'), '\\\\$&');\n  }\n  return str.replace(/[()\\[\\]{}|\\\\^$*+?.]/g, '\\\\$&');\n}\n\n// Look for characters that would change the meaning of subsequent tokens outside an interpolated value\nfunction getBreakoutChar(expression, regexContext, charClassContext) {\n  const escapesRemoved = expression.replace(/\\\\./gsu, '');\n  // Trailing unescaped `\\`; checking `.includes('\\\\')` would also work\n  if (escapesRemoved.endsWith('\\\\')) {\n    return '\\\\';\n  }\n  if (regexContext === RegexContext.DEFAULT) {\n    // Unbalanced `[` or `]` are also errors but don't breakout; they're caught by the wrapper\n    return getUnbalancedChar(escapesRemoved, '(', ')');\n  } else if (\n    regexContext === RegexContext.CHAR_CLASS &&\n    !enclosedTokenCharClassContexts.has(charClassContext)\n  ) {\n    return getUnbalancedChar(escapesRemoved, '[', ']');\n  } else if (\n    regexContext === RegexContext.INTERVAL_QUANTIFIER ||\n    enclosedTokenRegexContexts.has(regexContext) ||\n    enclosedTokenCharClassContexts.has(charClassContext)\n  ) {\n    if (escapesRemoved.includes('}')) {\n      return '}';\n    }\n  } else if (regexContext === RegexContext.GROUP_NAME) {\n    if (escapesRemoved.includes('>')) {\n      return '>';\n    }\n  }\n  return '';\n}\n\nconst contextToken = new RegExp(String.raw`\n(?<groupN>\\(\\?<(?![=!])|\\\\[gk]<)\n| (?<enclosedPU>\\\\[pPu]\\{)\n| (?<enclosedQ>\\\\q\\{)\n| (?<intervalQ>\\{)\n| (?<incompleteT>\\\\(?: $\n  | c(?![A-Za-z])\n  | u(?![A-Fa-f\\d]{4})[A-Fa-f\\d]{0,3}\n  | x(?![A-Fa-f\\d]{2})[A-Fa-f\\d]?\n  )\n)\n| --\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\n@typedef {{\n  regexContext: string;\n  charClassContext: string;\n  charClassDepth: number;\n  lastPos: number;\n}} RunningContext\n*/\n/**\nAccepts and returns its full state so it doesn't have to reprocess parts that have already been\nseen. Assumes flag v and doesn't worry about syntax errors that are caught by it.\n@param {string} incompleteExpression\n@param {Partial<RunningContext>} [runningContext]\n@returns {RunningContext}\n*/\nfunction getEndContextForIncompleteExpression(incompleteExpression, runningContext) {\n  let {regexContext, charClassContext, charClassDepth, lastPos} = {\n    regexContext: RegexContext.DEFAULT,\n    charClassContext: CharClassContext.DEFAULT,\n    charClassDepth: 0,\n    lastPos: 0,\n    ...runningContext,\n  };\n  contextToken.lastIndex = lastPos;\n  let match;\n  while (match = contextToken.exec(incompleteExpression)) {\n    const {0: m, groups: {groupN, enclosedPU, enclosedQ, intervalQ, incompleteT}} = match;\n    if (m === '[') {\n      charClassDepth++;\n      regexContext = RegexContext.CHAR_CLASS;\n      charClassContext = CharClassContext.DEFAULT;\n    } else if (m === ']' && regexContext === RegexContext.CHAR_CLASS) {\n      if (charClassDepth) {\n        charClassDepth--;\n      }\n      if (!charClassDepth) {\n        regexContext = RegexContext.DEFAULT;\n      }\n      charClassContext = CharClassContext.DEFAULT;\n    } else if (regexContext === RegexContext.CHAR_CLASS) {\n      if (incompleteT) {\n        charClassContext = CharClassContext.INVALID_INCOMPLETE_TOKEN;\n      } else if (m === '-') {\n        charClassContext = CharClassContext.RANGE;\n      } else if (enclosedPU) {\n        charClassContext = m[1] === 'u' ? CharClassContext.ENCLOSED_U : CharClassContext.ENCLOSED_P;\n      } else if (enclosedQ) {\n        charClassContext = CharClassContext.ENCLOSED_Q;\n      } else if (\n        (m === '}' && enclosedTokenCharClassContexts.has(charClassContext)) ||\n        // Don't continue in these contexts since we've advanced another token\n        charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN ||\n        charClassContext === CharClassContext.RANGE\n      ) {\n        charClassContext = CharClassContext.DEFAULT;\n      }\n    } else {\n      if (incompleteT) {\n        regexContext = RegexContext.INVALID_INCOMPLETE_TOKEN;\n      } else if (groupN) {\n        regexContext = RegexContext.GROUP_NAME;\n      } else if (enclosedPU) {\n        regexContext = m[1] === 'u' ? RegexContext.ENCLOSED_U : RegexContext.ENCLOSED_P;\n      } else if (intervalQ) {\n        regexContext = RegexContext.INTERVAL_QUANTIFIER;\n      } else if (\n        (m === '>' && regexContext === RegexContext.GROUP_NAME) ||\n        (m === '}' && (regexContext === RegexContext.INTERVAL_QUANTIFIER || enclosedTokenRegexContexts.has(regexContext))) ||\n        // Don't continue in this context since we've advanced another token\n        regexContext === RegexContext.INVALID_INCOMPLETE_TOKEN\n       ) {\n        regexContext = RegexContext.DEFAULT;\n      }\n    }\n  }\n  return {\n    regexContext,\n    charClassContext,\n    charClassDepth,\n    lastPos: incompleteExpression.length,\n  };\n}\n\n// No special handling for escaped versions of the characters\nfunction getUnbalancedChar(expression, leftChar, rightChar) {\n  let numOpen = 0;\n  for (const [m] of expression.matchAll(new RegExp(`[${escapeV(leftChar + rightChar, Context.CHAR_CLASS)}]`, 'g'))) {\n    numOpen += m === leftChar ? 1 : -1;\n    if (numOpen < 0) {\n      return rightChar;\n    }\n  }\n  if (numOpen > 0) {\n    return leftChar;\n  }\n  return '';\n}\n\n/**\n@typedef {import('./regex.js').InterpolatedValue} InterpolatedValue\n@typedef {import('./regex.js').RawTemplate} RawTemplate\n@typedef {import('./regex.js').RegexTagOptions} RegexTagOptions\n@typedef {(\n  value: InterpolatedValue,\n  runningContext: RunningContext,\n  options: Required<RegexTagOptions>\n) => {\n  transformed: string;\n  runningContext: RunningContext;\n}} Preprocessor\n*/\n/**\nReturns transformed versions of a template and substitutions, using the given preprocessor. Only\nprocesses substitutions that are instanceof `Pattern`.\n@param {RawTemplate} template\n@param {ReadonlyArray<InterpolatedValue>} substitutions\n@param {Preprocessor} preprocessor\n@param {Required<RegexTagOptions>} options\n@returns {{template: RawTemplate; substitutions: ReadonlyArray<InterpolatedValue>;}}\n*/\nfunction preprocess(template, substitutions, preprocessor, options) {\n  let /** @type {RawTemplate} */ newTemplate = {raw: []};\n  let newSubstitutions = [];\n  let runningContext;\n  template.raw.forEach((raw, i) => {\n    const result = preprocessor(raw, {...runningContext, lastPos: 0}, options);\n    newTemplate.raw.push(result.transformed);\n    runningContext = result.runningContext;\n    if (i < template.raw.length - 1